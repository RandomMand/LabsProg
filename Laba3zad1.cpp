#include <iostream>

double a = 0;
void f(double x) {
    a = x;
}

struct A {

    double a;
    void f() {
        a = 2;
    }
};

class B : A { // private-наследование, поэтому члены A недоступны
public:
    void f(int a) {
        ::a = a; // Здесь все верно, но глобальная `a` используется
    }
    void g();
};

void B::g() {
    f(1.2); // Ошибка: в `B` есть только `f(int)`, но `f(double)` нет.
        // Правильный вариант: `::f(1.2);`

    f();    // Ошибка: `A::f()` недоступен, так как `A` унаследован `private`.
        // Правильный вариант: либо сделать `A::f()` `public`, либо `B` `public A`

    a = 2;  // Ошибка: `a` принадлежит `A` и недоступен в `B` из-за `private`-наследования.
        // Правильный вариант: `::a = 2;` для работы с глобальной переменной
}

void empty(B & a, B b) {

}

int main() {
    B d;
    f();    // Ошибка: `f()` без аргументов не существует.
        // Правильный вариант: `f(0.0);` или добавить `void f();`

    f(6);

    empty(d, d); // `d` копируется, вызывая конструктор копирования (если он не удален)

    return 0;
}


// A() → B() → A(B) → B(B) → ~B() → ~A() → ~B() → ~A()
